// src/components/WarehousePage.jsx
import React, { useEffect, useMemo, useState, useCallback } from "react";

const API = "https://arkanaltafawuq.com/arkan-system";

const tiny = {
  btn: {
    padding: "6px 10px",
    border: "none",
    borderRadius: 4,
    cursor: "pointer",
  },
  input: { padding: 8, borderRadius: 6, border: "1px solid #ddd" },
  card: { border: "1px solid #e5e5e5", borderRadius: 10, padding: 16 },
};

const WarehousePage = () => {
  const [tab, setTab] = useState("stock"); // stock | add | in | out | movements
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [movementFilters, setMovementFilters] = useState({
    item_id: "",
    from: "",
    to: "",
    limit: 100,
  });

  // STOCK filters (NEW)
  const [stockFilters, setStockFilters] = useState({
    q: "",             // text search (code/name/desc/location)
    category: "",      // exact match
    location: "",      // exact match
    lowOnly: false,    // only items below/at reorder level
    minQty: "",        // >=
    maxQty: "",        // <=
  });

  // Add Item form
  const [newItem, setNewItem] = useState({
    item_code: "",
    item_name: "",
    description: "",
    category: "",
    quantity: "", // initial qty
    unit: "pcs",
    purchase_price: "",
    selling_price: "",
    supplier_id: "",
    reorder_level: "",
    location: "",
  });

  // IN form
  const [inForm, setInForm] = useState({
    item_id: "",
    qty: "",
    unit_cost: "",
    supplier_id: "",
    po_number: "",
    note: "",
  });

  // OUT form
  const [outForm, setOutForm] = useState({
    item_id: "",
    qty: "",
    reason: "usage",
    order_id: "",
    note: "",
  });

  // Movements list
  const [inRows, setInRows] = useState([]);
  const [outRows, setOutRows] = useState([]);

  const username = localStorage.getItem("username") || "";

  const fetchItems = async () => {
    setLoading(true);
    try {
      const res = await fetch(`${API}/warehouse_get_items.php`);
      const data = await res.json();
      if (data.success) setItems(Array.isArray(data.items) ? data.items : []);
      else setItems([]);
    } catch (e) {
      console.error(e);
      setItems([]);
    } finally {
      setLoading(false);
    }
  };

  const fetchIn = useCallback(async () => {
    const qs = new URLSearchParams();
    if (movementFilters.item_id) qs.append("item_id", movementFilters.item_id);
    if (movementFilters.from) qs.append("from", movementFilters.from);
    if (movementFilters.to) qs.append("to", movementFilters.to);
    if (movementFilters.limit) qs.append("limit", movementFilters.limit);
    
    try {
      const res = await fetch(`${API}/warehouse_get_in.php?` + qs.toString());
      const data = await res.json();
      setInRows(Array.isArray(data.rows) ? data.rows : []);
    } catch (error) {
      console.error('Error fetching in movements:', error);
      setInRows([]);
    }
  }, [movementFilters]);

  const fetchOut = useCallback(async () => {
    const qs = new URLSearchParams();
    if (movementFilters.item_id) qs.append("item_id", movementFilters.item_id);
    if (movementFilters.from) qs.append("from", movementFilters.from);
    if (movementFilters.to) qs.append("to", movementFilters.to);
    if (movementFilters.limit) qs.append("limit", movementFilters.limit);
    
    try {
      const res = await fetch(`${API}/warehouse_get_out.php?` + qs.toString());
      const data = await res.json();
      setOutRows(Array.isArray(data.rows) ? data.rows : []);
    } catch (error) {
      console.error('Error fetching out movements:', error);
      setOutRows([]);
    }
  }, [movementFilters]);

  useEffect(() => {
    if (tab === "stock") fetchItems();
    if (tab === "in") { fetchItems(); fetchIn(); }
    if (tab === "out") { fetchItems(); fetchOut(); }
    if (tab === "movements") { fetchIn(); fetchOut(); }
  }, [tab, fetchIn, fetchOut]);

  const addItem = async (e) => {
    e.preventDefault();
    const payload = {
      item_code: newItem.item_code,
      item_name: newItem.item_name,
      description: newItem.description,
      category: newItem.category,
      qty: parseFloat(newItem.quantity || 0),
      unit: newItem.unit,
      purchase_price: parseFloat(newItem.purchase_price || 0),
      selling_price: parseFloat(newItem.selling_price || 0),
      supplier_id: newItem.supplier_id || null,
      reorder_level: parseFloat(newItem.reorder_level || 0),
      location: newItem.location,
    };

    const res = await fetch(`${API}/warehouse_add_item.php`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    const data = await res.json();
    if (data.success) {
      alert("✅ Item added");
      setNewItem({
        item_code: "",
        item_name: "",
        description: "",
        category: "",
        quantity: "",
        unit: "pcs",
        purchase_price: "",
        selling_price: "",
        supplier_id: "",
        reorder_level: "",
        location: "",
      });
      setTab("stock");
      fetchItems();
    } else {
      alert("❌ " + (data.message || "Failed to add item"));
    }
  };

  const addIn = async (e) => {
    e.preventDefault();
    const payload = {
      item_id: parseInt(inForm.item_id, 10),
      qty: parseFloat(inForm.qty || 0),
      unit_cost: inForm.unit_cost === "" ? null : parseFloat(inForm.unit_cost),
      supplier_id: inForm.supplier_id === "" ? null : parseInt(inForm.supplier_id, 10),
      po_number: inForm.po_number || null,
      note: inForm.note || null,
      received_by: username || null,
    };
    const res = await fetch(`${API}/warehouse_add_in.php`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    const data = await res.json();
    if (data.success) {
      alert("✅ Stock IN recorded");
      setInForm({ item_id: "", qty: "", unit_cost: "", supplier_id: "", po_number: "", note: "" });
      fetchItems();
      fetchIn();
    } else {
      alert("❌ " + (data.message || "Failed to add IN"));
    }
  };

  const addOut = async (e) => {
    e.preventDefault();
    const payload = {
      item_id: parseInt(outForm.item_id, 10),
      qty: parseFloat(outForm.qty || 0),
      reason: outForm.reason || "usage",
      order_id: outForm.order_id === "" ? null : parseInt(outForm.order_id, 10),
      note: outForm.note || null,
      issued_by: username || null,
    };
    const res = await fetch(`${API}/warehouse_add_out.php`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    const data = await res.json();
    if (data.success) {
      alert("✅ Stock OUT recorded");
      setOutForm({ item_id: "", qty: "", reason: "usage", order_id: "", note: "" });
      fetchItems();
      fetchOut();
    } else {
      alert("❌ " + (data.message || "Failed to add OUT"));
    }
  };

  const quickAdjust = async (item_id, delta) => {
    if (delta > 0) {
      await fetch(`${API}/warehouse_add_in.php`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          item_id,
          qty: 1,
          unit_cost: null,
          supplier_id: null,
          po_number: "quick-adjust",
          note: delta > 0 ? "quick +1" : "quick -1",
          received_by: username || null,
        }),
      });
    } else {
      await fetch(`${API}/warehouse_add_out.php`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          item_id,
          qty: 1,
          reason: "adjustment",
          order_id: null,
          note: "quick -1",
          issued_by: username || null,
        }),
      });
    }
    fetchItems();
    if (tab === "movements") { fetchIn(); fetchOut(); }
  };

  const itemsById = useMemo(() => {
    const map = new Map();
    items.forEach((i) => map.set(String(i.item_id), i));
    return map;
  }, [items]);

  // === STOCK: derived UI data (NEW) ===
  const categoryOptions = useMemo(() => {
    const set = new Set(items.map(i => (i.category || "").trim()).filter(Boolean));
    return Array.from(set).sort();
  }, [items]);

  const locationOptions = useMemo(() => {
    const set = new Set(items.map(i => (i.location || "").trim()).filter(Boolean));
    return Array.from(set).sort();
  }, [items]);

  const filteredItems = useMemo(() => {
    const q = stockFilters.q.trim().toLowerCase();
    const cat = stockFilters.category.trim().toLowerCase();
    const loc = stockFilters.location.trim().toLowerCase();
    const min = stockFilters.minQty === "" ? null : Number(stockFilters.minQty);
    const max = stockFilters.maxQty === "" ? null : Number(stockFilters.maxQty);

    return items.filter(it => {
      const qty = Number(it.quantity || 0);
      const reorder = Number(it.reorder_level || 0);

      if (stockFilters.lowOnly && !(qty <= reorder)) return false;

      if (min !== null && !(qty >= min)) return false;
      if (max !== null && !(qty <= max)) return false;

      if (cat && String(it.category || "").toLowerCase() !== cat) return false;
      if (loc && String(it.location || "").toLowerCase() !== loc) return false;

      if (q) {
        const hay = [
          it.item_code,
          it.item_name,
          it.description,
          it.location,
          it.category,
        ].map(v => String(v || "").toLowerCase()).join(" ");
        if (!hay.includes(q)) return false;
      }

      return true;
    });
  }, [items, stockFilters]);

  // Export current filtered stock to CSV (NEW)
  const exportStockCSV = () => {
    const headers = [
      "ID","Code","Name","Quantity","Unit","Reorder Level","Location","Category",
      "Purchase Price","Selling Price","Supplier ID","Description"
    ];

    const rows = filteredItems.map(it => ([
      it.item_id ?? "",
      it.item_code ?? "",
      it.item_name ?? "",
      it.quantity ?? "",
      it.unit ?? "",
      it.reorder_level ?? "",
      it.location ?? "",
      it.category ?? "",
      it.purchase_price ?? "",
      it.selling_price ?? "",
      it.supplier_id ?? "",
      (it.description ?? "").replace(/\r?\n/g, " "),
    ]));

    const escape = (v) => {
      const s = String(v ?? "");
      // quote if contains quotes, commas, or newlines
      if (/[",\n]/.test(s)) {
        return `"${s.replace(/"/g, '""')}"`;
      }
      return s;
    };

    const csv = [headers, ...rows].map(r => r.map(escape).join(",")).join("\n");
    const blob = new Blob(["\uFEFF" + csv], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const today = new Date().toISOString().slice(0,10);
    a.download = `warehouse_stock_${today}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  const clearStockFilters = () => {
    setStockFilters({ q: "", category: "", location: "", lowOnly: false, minQty: "", maxQty: "" });
  };

  return (
    <div style={{ padding: 20 }}>
      <h2>📦 Warehouse</h2>

      {/* Tabs */}
      <div style={{ display: "flex", gap: 10, marginBottom: 16 }}>
        {["stock", "add", "in", "out", "movements"].map((t) => (
          <button
            key={t}
            onClick={() => setTab(t)}
            style={{
              ...tiny.btn,
              background: tab === t ? "#333" : "#ccc",
              color: tab === t ? "#fff" : "#000",
            }}
          >
            {t.toUpperCase()}
          </button>
        ))}
      </div>

      {/* STOCK */}
      {tab === "stock" && (
        <div>
          {/* Toolbar */}
          <div style={{ display: "flex", gap: 10, marginBottom: 10, flexWrap: "wrap" }}>
            <button
              style={{ ...tiny.btn, background: "#f3f3f3", color: "#000" }}
              onClick={fetchItems}
              disabled={loading}
              title="Refresh items"
            >
              {loading ? "Loading..." : "Refresh"}
            </button>
            {/* Export (NEW) */}
            <button
              style={{ ...tiny.btn, background: "#333", color: "#fff" }}
              onClick={exportStockCSV}
              title="Export current view to CSV"
            >
              ⭳ Export CSV
            </button>
            <div style={{ alignSelf: "center", color: "#555" }}>
              Showing <b>{filteredItems.length}</b> of <b>{items.length}</b> items
            </div>
          </div>

          {/* Filters (NEW) */}
          <div style={{ ...tiny.card, display: "grid", gap: 10, gridTemplateColumns: "2fr 1fr 1fr 1fr 1fr auto" }}>
            <input
              style={tiny.input}
              placeholder="Search (code, name, description, location)"
              value={stockFilters.q}
              onChange={(e) => setStockFilters({ ...stockFilters, q: e.target.value })}
            />
            <select
              style={tiny.input}
              value={stockFilters.category}
              onChange={(e) => setStockFilters({ ...stockFilters, category: e.target.value })}
            >
              <option value="">All categories</option>
              {categoryOptions.map(c => <option key={c} value={c}>{c}</option>)}
            </select>
            <select
              style={tiny.input}
              value={stockFilters.location}
              onChange={(e) => setStockFilters({ ...stockFilters, location: e.target.value })}
            >
              <option value="">All locations</option>
              {locationOptions.map(l => <option key={l} value={l}>{l}</option>)}
            </select>
            <input
              style={tiny.input}
              type="number"
              step="0.01"
              placeholder="Min qty"
              value={stockFilters.minQty}
              onChange={(e) => setStockFilters({ ...stockFilters, minQty: e.target.value })}
            />
            <input
              style={tiny.input}
              type="number"
              step="0.01"
              placeholder="Max qty"
              value={stockFilters.maxQty}
              onChange={(e) => setStockFilters({ ...stockFilters, maxQty: e.target.value })}
            />
            <label style={{ display: "flex", alignItems: "center", gap: 6 }}>
              <input
                type="checkbox"
                checked={stockFilters.lowOnly}
                onChange={(e) => setStockFilters({ ...stockFilters, lowOnly: e.target.checked })}
              />
              Low only
            </label>
            <div style={{ gridColumn: "1 / -1" }}>
              <button
                style={{ ...tiny.btn, background: "#f3f3f3" }}
                onClick={clearStockFilters}
                title="Clear all filters"
              >
                Clear Filters
              </button>
            </div>
          </div>

          {/* Table */}
          <div style={{ overflowX: "auto", marginTop: 10 }}>
            <table border="1" cellPadding="8" width="100%">
              <thead>
                <tr>
                  <th>ID</th>
                  <th>Code</th>
                  <th>Name</th>
                  <th>Qty</th>
                  <th>Unit</th>
                  <th>Min</th>
                  <th>Location</th>
                  <th>Quick +/-</th>
                  {/* <th>Actions</th> */}
                </tr>
              </thead>
              <tbody>
                {filteredItems.map((it) => {
                  const low = Number(it.quantity) <= Number(it.reorder_level || 0);
                  return (
                    <tr key={it.item_id} style={low ? { background: "#fff4f4" } : undefined}>
                      <td>{it.item_id}</td>
                      <td>{it.item_code || "-"}</td>
                      <td>{it.item_name}</td>
                      <td>{it.quantity}</td>
                      <td>{it.unit}</td>
                      <td>{it.reorder_level ?? "-"}</td>
                      <td>{it.location ?? "-"}</td>
                      <td>
                        <button
                          style={{ ...tiny.btn, background: "#e6fff0", color: "#0a6" }}
                          onClick={() => quickAdjust(it.item_id, +1)}
                        >
                          +1
                        </button>{" "}
                        <button
                          style={{ ...tiny.btn, background: "#ffecec", color: "#c00" }}
                          onClick={() => quickAdjust(it.item_id, -1)}
                        >
                          -1
                        </button>
                      </td>
                    </tr>
                  );
                })}
                {filteredItems.length === 0 && (
                  <tr>
                    <td colSpan="9">No items</td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>
        </div>
      )}

      {/* ADD ITEM */}
      {tab === "add" && (
        <div style={{ display: "grid", gap: 16, maxWidth: 720 }}>
          <form onSubmit={addItem} style={{ ...tiny.card, display: "grid", gap: 10 }}>
            <h3>➕ Add Item</h3>
            <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 10 }}>
              <input
                style={tiny.input}
                placeholder="Item Code (unique)"
                value={newItem.item_code}
                onChange={(e) => setNewItem({ ...newItem, item_code: e.target.value })}
              />
              <input
                style={tiny.input}
                placeholder="Item Name *"
                required
                value={newItem.item_name}
                onChange={(e) => setNewItem({ ...newItem, item_name: e.target.value })}
              />
              <input
                style={tiny.input}
                placeholder="Category"
                value={newItem.category}
                onChange={(e) => setNewItem({ ...newItem, category: e.target.value })}
              />
              <input
                style={tiny.input}
                placeholder="Location"
                value={newItem.location}
                onChange={(e) => setNewItem({ ...newItem, location: e.target.value })}
              />
              <input
                style={tiny.input}
                placeholder="Unit (pcs/m/etc)"
                value={newItem.unit}
                onChange={(e) => setNewItem({ ...newItem, unit: e.target.value })}
              />
              <input
                style={tiny.input}
                type="number"
                step="0.01"
                placeholder="Initial Qty"
                value={newItem.quantity}
                onChange={(e) => setNewItem({ ...newItem, quantity: e.target.value })}
              />
              <input
                style={tiny.input}
                type="number"
                step="0.01"
                placeholder="Reorder Level"
                value={newItem.reorder_level}
                onChange={(e) => setNewItem({ ...newItem, reorder_level: e.target.value })}
              />
              <input
                style={tiny.input}
                type="number"
                step="0.01"
                placeholder="Purchase Price"
                value={newItem.purchase_price}
                onChange={(e) => setNewItem({ ...newItem, purchase_price: e.target.value })}
              />
              <input
                style={tiny.input}
                type="number"
                step="0.01"
                placeholder="Selling Price"
                value={newItem.selling_price}
                onChange={(e) => setNewItem({ ...newItem, selling_price: e.target.value })}
              />
              <input
                style={tiny.input}
                placeholder="Supplier ID (optional)"
                value={newItem.supplier_id}
                onChange={(e) => setNewItem({ ...newItem, supplier_id: e.target.value })}
              />
            </div>
            <textarea
              style={{ ...tiny.input, minHeight: 80 }}
              placeholder="Description"
              value={newItem.description}
              onChange={(e) => setNewItem({ ...newItem, description: e.target.value })}
            />
            <div>
              <button style={{ ...tiny.btn, background: "#333", color: "#fff" }} type="submit">
                Save Item
              </button>
            </div>
          </form>
        </div>
      )}

      {/* STOCK IN */}
      {tab === "in" && (
        <div style={{ display: "grid", gap: 16 }}>
          <form onSubmit={addIn} style={{ ...tiny.card, display: "grid", gap: 10 }}>
            <h3>⬆️ Stock IN</h3>
            <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 10 }}>
              <select
                style={tiny.input}
                value={inForm.item_id}
                onChange={(e) => setInForm({ ...inForm, item_id: e.target.value })}
              >
                <option value="">Select Item</option>
                {items.map((i) => (
                  <option key={i.item_id} value={i.item_id}>
                    #{i.item_id} — {i.item_name} ({i.item_code || "no-code"})
                  </option>
                ))}
              </select>
              <input
                style={tiny.input}
                type="number"
                step="0.01"
                placeholder="Qty"
                value={inForm.qty}
                onChange={(e) => setInForm({ ...inForm, qty: e.target.value })}
              />
              <input
                style={tiny.input}
                type="number"
                step="0.0001"
                placeholder="Unit Cost (optional)"
                value={inForm.unit_cost}
                onChange={(e) => setInForm({ ...inForm, unit_cost: e.target.value })}
              />
              <input
                style={tiny.input}
                placeholder="Supplier ID (optional)"
                value={inForm.supplier_id}
                onChange={(e) => setInForm({ ...inForm, supplier_id: e.target.value })}
              />
              <input
                style={tiny.input}
                placeholder="PO Number"
                value={inForm.po_number}
                onChange={(e) => setInForm({ ...inForm, po_number: e.target.value })}
              />
              <input
                style={{ ...tiny.input, gridColumn: "span 3" }}
                placeholder="Note"
                value={inForm.note}
                onChange={(e) => setInForm({ ...inForm, note: e.target.value })}
              />
            </div>
            <div>
              <button style={{ ...tiny.btn, background: "#333", color: "#fff" }} type="submit">
                Add IN
              </button>
            </div>
          </form>

          {/* IN LIST */}
          <MovementFilters filters={movementFilters} setFilters={setMovementFilters} onApply={() => { fetchIn(); }} />
          <MovementInTable rows={inRows} />
        </div>
      )}

      {/* STOCK OUT */}
      {tab === "out" && (
        <div style={{ display: "grid", gap: 16 }}>
          <form onSubmit={addOut} style={{ ...tiny.card, display: "grid", gap: 10 }}>
            <h3>⬇️ Stock OUT</h3>
            <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 10 }}>
              <select
                style={tiny.input}
                value={outForm.item_id}
                onChange={(e) => setOutForm({ ...outForm, item_id: e.target.value })}
              >
                <option value="">Select Item</option>
                {items.map((i) => (
                  <option key={i.item_id} value={i.item_id}>
                    #{i.item_id} — {i.item_name} ({i.item_code || "no-code"})
                  </option>
                ))}
              </select>
              <input
                style={tiny.input}
                type="number"
                step="0.01"
                placeholder="Qty"
                value={outForm.qty}
                onChange={(e) => setOutForm({ ...outForm, qty: e.target.value })}
              />
              <select
                style={tiny.input}
                value={outForm.reason}
                onChange={(e) => setOutForm({ ...outForm, reason: e.target.value })}
              >
                <option value="usage">usage</option>
                <option value="production">production</option>
                <option value="sale">sale</option>
                <option value="adjustment">adjustment</option>
                <option value="transfer">transfer</option>
              </select>
              <input
                style={tiny.input}
                placeholder="Order ID (optional)"
                value={outForm.order_id}
                onChange={(e) => setOutForm({ ...outForm, order_id: e.target.value })}
              />
              <input
                style={{ ...tiny.input, gridColumn: "span 3" }}
                placeholder="Note"
                value={outForm.note}
                onChange={(e) => setOutForm({ ...outForm, note: e.target.value })}
              />
            </div>
            <div>
              <button style={{ ...tiny.btn, background: "#333", color: "#fff" }} type="submit">
                Add OUT
              </button>
            </div>
          </form>

          {/* OUT LIST */}
          <MovementFilters 
            filters={movementFilters} 
            setFilters={setMovementFilters} 
            onApply={() => fetchOut()} 
          />
          <MovementOutTable rows={outRows} />
        </div>
      )}

      {/* MOVEMENTS (combined) */}
      {tab === "movements" && (
        <div style={{ margin: '20px 0' }}>
          <h2>Warehouse Movements</h2>
          <MovementFilters
            filters={movementFilters}
            setFilters={setMovementFilters}
            onApply={() => {
              fetchIn();
              fetchOut();
            }}
          />
          <MovementTable inRows={inRows} outRows={outRows} />
        </div>
      )}
    </div>
  );
};

      const inItem = inRows.find(inRow => inRow.item_id === r.item_id);
      const unitCost = inItem ? (parseFloat(inItem.unit_cost) || 0) : 0;
      return {
        ...r,
        type: 'out',
        date: r.issued_at,
        qty: -Math.abs(+r.qty),
        value: parseFloat(r.qty) * unitCost,
        by: r.issued_by,
        reference: r.order_id ? `Order: ${r.order_id}` : '',
        details: r.reason ? `Reason: ${r.reason}` : ''
      };
    });
    
    return [...ins, ...outs].sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [inRows, outRows]);

  return (
    <div>
      <div style={{ overflowX: "auto", marginBottom: '20px' }}>
        <table border="1" cellPadding="8" width="100%">
          <thead>
            <tr>
              <th>Date</th>
              <th>Type</th>
              <th>Item</th>
              <th>Qty</th>
              <th>Value</th>
              <th>Reference</th>
              <th>Details</th>
              <th>By</th>
              <th>Note</th>
            </tr>
          </thead>
          <tbody>
            {allMovements.map((r) => (
              <tr key={`${r.type}-${r.id}`}>
                <td>{r.date}</td>
                <td style={{ 
                  color: r.type === 'in' ? '#0a6' : '#c00',
                  fontWeight: 600
                }}>
                  {r.type.toUpperCase()}
                </td>
                <td>
                  #{r.item_id} — {r.item_code} / {r.item_name}
                </td>
                <td style={{ 
                  color: r.type === 'in' ? '#0a6' : '#c00',
                  fontWeight: 600
                }}>
                  {r.type === 'in' ? '+' : ''}{r.qty}
                </td>
                <td>{r.value.toFixed(2)}</td>
                <td>{r.reference || '-'}</td>
                <td>{r.details || '-'}</td>
                <td>{r.by || '-'}</td>
                <td>{r.note || '-'}</td>
              </tr>
            ))}
            {allMovements.length === 0 && (
              <tr>
                <td colSpan="9">No movements found</td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
      
      <div style={{ 
        display: 'flex', 
        justifyContent: 'flex-end',
        gap: '30px',
        marginTop: '20px',
        padding: '15px',
        backgroundColor: '#f8f9fa',
        borderRadius: '8px',
        border: '1px solid #e9ecef'
      }}>
        <div style={{ textAlign: 'right' }}>
          <div style={{ color: '#6c757d', fontSize: '0.9em' }}>Total In Value</div>
          <div style={{ fontSize: '1.2em', fontWeight: 'bold', color: '#0a6' }}>
            ${totalInValue.toFixed(2)}
          </div>
        </div>
        <div style={{ textAlign: 'right' }}>
          <div style={{ color: '#6c757d', fontSize: '0.9em' }}>Total Out Value</div>
          <div style={{ fontSize: '1.2em', fontWeight: 'bold', color: '#c00' }}>
            ${totalOutValue.toFixed(2)}
          </div>
        </div>
        <div style={{ textAlign: 'right' }}>
          <div style={{ color: '#6c757d', fontSize: '0.9em' }}>Net Value</div>
          <div style={{ 
            fontSize: '1.4em', 
            fontWeight: 'bold',
            color: netValue >= 0 ? '#0a6' : '#c00'
          }}>
            ${Math.abs(netValue).toFixed(2)} {netValue >= 0 ? '' : '('} 
            {netValue >= 0 ? 'Profit' : 'Loss'}{netValue >= 0 ? '' : ')'}
          </div>
        </div>
      </div>
    </div>
  );
};

const MovementTable = ({ inRows, outRows }) => {
  // Calculate total values
  const totalInValue = useMemo(() => 
    inRows.reduce((sum, row) => sum + (parseFloat(row.total_cost) || 0), 0), 
    [inRows]
  );

  const totalOutValue = useMemo(() => 
    outRows.reduce((sum, row) => {
      const inItem = inRows.find(inRow => inRow.item_id === row.item_id);
      const avgCost = inItem ? (parseFloat(inItem.unit_cost) || 0) : 0;
      return sum + (parseFloat(row.qty) * avgCost);
    }, 0), 
    [outRows, inRows]
  );

  const netValue = totalInValue - totalOutValue;

  // Combine and sort movements by date
  const allMovements = useMemo(() => {
      const inItem = inRows.find(inRow => inRow.item_id === r.item_id);
      const unitCost = inItem ? (parseFloat(inItem.unit_cost) || 0) : 0;
      return {
        ...r,
        type: 'out',
        date: r.issued_at,
        qty: -Math.abs(+r.qty),
        value: parseFloat(r.qty) * unitCost,
        by: r.issued_by,
        reference: r.order_id ? `Order: ${r.order_id}` : '',
        details: r.reason ? `Reason: ${r.reason}` : ''
      };
    });
    
    return [...ins, ...outs].sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [inRows, outRows]);

  return (
    <div>
      <div style={{ overflowX: "auto", marginBottom: '20px' }}>
        <table border="1" cellPadding="8" width="100%">
          <thead>
            <tr>
              <th>Date</th>
              <th>Type</th>
              <th>Item</th>
              <th>Qty</th>
              <th>Value</th>
              <th>Reference</th>
              <th>Details</th>
              <th>By</th>
              <th>Note</th>
            </tr>
          </thead>
          <tbody>
            {allMovements.map((r) => (
              <tr key={`${r.type}-${r.id}`}>
                <td>{r.date}</td>
                <td style={{ 
                  color: r.type === 'in' ? '#0a6' : '#c00',
                  fontWeight: 600
                }}>
                  {r.type.toUpperCase()}
                </td>
                <td>
                  #{r.item_id} — {r.item_code} / {r.item_name}
                </td>
                <td style={{ 
                  color: r.type === 'in' ? '#0a6' : '#c00',
                  fontWeight: 600
                }}>
                  {r.type === 'in' ? '+' : ''}{r.qty}
                </td>
                <td>{r.value.toFixed(2)}</td>
                <td>{r.reference || '-'}</td>
                <td>{r.details || '-'}</td>
                <td>{r.by || '-'}</td>
                <td>{r.note || '-'}</td>
              </tr>
            ))}
            {allMovements.length === 0 && (
              <tr>
                <td colSpan="9">No movements found</td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
      
      <div style={{ 
        display: 'flex', 
        justifyContent: 'flex-end',
        gap: '30px',
        marginTop: '20px',
        padding: '15px',
        backgroundColor: '#f8f9fa',
        borderRadius: '8px',
        border: '1px solid #e9ecef'
      }}>
        <div style={{ textAlign: 'right' }}>
          <div style={{ color: '#6c757d', fontSize: '0.9em' }}>Total In Value</div>
          <div style={{ fontSize: '1.2em', fontWeight: 'bold', color: '#0a6' }}>
            ${totalInValue.toFixed(2)}
          </div>
        </div>
        <div style={{ textAlign: 'right' }}>
          <div style={{ color: '#6c757d', fontSize: '0.9em' }}>Total Out Value</div>
          <div style={{ fontSize: '1.2em', fontWeight: 'bold', color: '#c00' }}>
            ${totalOutValue.toFixed(2)}
          </div>
        </div>
        <div style={{ textAlign: 'right' }}>
          <div style={{ color: '#6c757d', fontSize: '0.9em' }}>Net Value</div>
          <div style={{ 
            fontSize: '1.4em', 
            fontWeight: 'bold',
            color: netValue >= 0 ? '#0a6' : '#c00'
          }}>
            ${Math.abs(netValue).toFixed(2)} {netValue >= 0 ? '' : '('} 
            {netValue >= 0 ? 'Profit' : 'Loss'}{netValue >= 0 ? '' : ')'}
          </div>
        </div>
      </div>
    </div>
  );
};

const MovementFilters = ({ filters, setFilters, onApply }) => {
  return (
    <div style={{ ...tiny.card, display: "flex", gap: 10, alignItems: "center" }}>
      <input
        style={tiny.input}
        placeholder="Item ID"
        value={filters.item_id}
        onChange={(e) => setFilters({ ...filters, item_id: e.target.value })}
      />
      <input
        style={tiny.input}
        type="date"
        value={filters.from}
        onChange={(e) => setFilters({ ...filters, from: e.target.value })}
      />
      <input
        style={tiny.input}
        type="date"
        value={filters.to}
        onChange={(e) => setFilters({ ...filters, to: e.target.value })}
      />
      <input
        style={{ ...tiny.input, width: 100 }}
        type="number"
        value={filters.limit}
        onChange={(e) => setFilters({ ...filters, limit: Number(e.target.value || 100) })}
      />
      <button style={{ ...tiny.btn, background: "#333", color: "#fff" }} onClick={onApply}>
        Apply
      </button>
    </div>
  );
};

      const inItem = inRows.find(inRow => inRow.item_id === r.item_id);
      const unitCost = inItem ? (parseFloat(inItem.unit_cost) || 0) : 0;
      return {
        ...r,
        type: 'out',
        date: r.issued_at,
        qty: -Math.abs(+r.qty),
        value: parseFloat(r.qty) * unitCost,
        by: r.issued_by,
        reference: r.order_id ? `Order: ${r.order_id}` : '',
        details: r.reason ? `Reason: ${r.reason}` : ''
      };
    });
    
    return [...ins, ...outs].sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [inRows, outRows]);

  return (
    <div>
      <div style={{ overflowX: "auto", marginBottom: '20px' }}>
        <table border="1" cellPadding="8" width="100%">
          <thead>
            <tr>
              <th>Date</th>
              <th>Type</th>
              <th>Item</th>
              <th>Qty</th>
              <th>Value</th>
              <th>Reference</th>
              <th>Details</th>
              <th>By</th>
              <th>Note</th>
            </tr>
          </thead>
          <tbody>
            {allMovements.map((r) => (
              <tr key={`${r.type}-${r.id}`}>
                <td>{r.date}</td>
                <td style={{ 
                  color: r.type === 'in' ? '#0a6' : '#c00',
                  fontWeight: 600
                }}>
                  {r.type.toUpperCase()}
                </td>
                <td>
                  #{r.item_id} — {r.item_code} / {r.item_name}
                </td>
                <td style={{ 
                  color: r.type === 'in' ? '#0a6' : '#c00',
                  fontWeight: 600
                }}>
                  {r.type === 'in' ? '+' : ''}{r.qty}
                </td>
                <td>{r.value.toFixed(2)}</td>
                <td>{r.reference || '-'}</td>
                <td>{r.details || '-'}</td>
                <td>{r.by || '-'}</td>
                <td>{r.note || '-'}</td>
              </tr>
            ))}
            {allMovements.length === 0 && (
              <tr>
                <td colSpan="9">No movements found</td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
      
      <div style={{ 
        display: 'flex', 
        justifyContent: 'flex-end',
        gap: '30px',
        marginTop: '20px',
        padding: '15px',
        backgroundColor: '#f8f9fa',
        borderRadius: '8px',
        border: '1px solid #e9ecef'
      }}>
        <div style={{ textAlign: 'right' }}>
          <div style={{ color: '#6c757d', fontSize: '0.9em' }}>Total In Value</div>
          <div style={{ fontSize: '1.2em', fontWeight: 'bold', color: '#0a6' }}>
            ${totalInValue.toFixed(2)}
          </div>
        </div>
        <div style={{ textAlign: 'right' }}>
          <div style={{ color: '#6c757d', fontSize: '0.9em' }}>Total Out Value</div>
          <div style={{ fontSize: '1.2em', fontWeight: 'bold', color: '#c00' }}>
            ${totalOutValue.toFixed(2)}
          </div>
        </div>
        <div style={{ textAlign: 'right' }}>
          <div style={{ color: '#6c757d', fontSize: '0.9em' }}>Net Value</div>
          <div style={{ 
            fontSize: '1.4em', 
            fontWeight: 'bold',
            color: netValue >= 0 ? '#0a6' : '#c00'
          }}>
            ${Math.abs(netValue).toFixed(2)} {netValue >= 0 ? '' : '('} 
            {netValue >= 0 ? 'Profit' : 'Loss'}{netValue >= 0 ? '' : ')'}
          </div>
        </div>
      </div>
    </div>
  );
};

export default WarehousePage;
